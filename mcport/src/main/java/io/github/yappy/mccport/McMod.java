/*
 * This source file was generated by the Gradle 'init' task
 */
package io.github.yappy.mccport;

import java.awt.Image;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

import javax.imageio.ImageIO;

import com.google.common.base.Charsets;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.io.Resources;

import io.github.yappy.mcutil.McParam;
import javassist.ByteArrayClassPath;
import javassist.CannotCompileException;
import javassist.ClassMap;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.NotFoundException;

public class McMod {

    public enum McVersion {
        MC_2_8, MC_3_0
    }

    public static int MC_APPLET_W = 512;
    public static int MC_APPLET_H = 320;
    public static int MC_MAP_W = 180;
    public static int MC_MAP_W_PART = 60;
    public static int MC_MAP_H = 30;

    // ....mc2.MasaoConstruction etc.
    private static final String PKG_CLS_FMT = "io.github.yappy.%s.%s";

    // Singleton(s)
    private static final Map<McVersion, McMod> INSTANCES;

    static {
        McMod mc2;
        try {
            List<String> classes = ImmutableList.of(
                    "CharacterObject", "GameGraphics", "GameKey", "GameMouse", "IdouGamen", "KeyboardMenu",
                    "MainProgram", "MapSystem", "MasaoConstruction");
            List<String> images = ImmutableList.of(
                    "chizu.gif", "ending.gif", "gameover.gif", "pattern.gif", "title.gif");
            List<String> sounds = ImmutableList.of();
            mc2 = new McMod("mc2", classes, "game1", images, sounds);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        McMod mc3;
        try {
            List<String> classes = ImmutableList.of(
                    "CharacterObject", "GameGraphics", "GameKey", "GameSound", "GameMouse", "IdouGamen", "KeyboardMenu",
                    "MainProgram", "MapSystem", "MasaoConstruction");
            List<String> images = ImmutableList.of(
                    "chizu.gif", "ending.gif", "gameover.gif", "haikei.gif", "mapchip.gif", "pattern.gif", "title.gif");
            List<String> sounds = ImmutableList.of("bakuhatu.au", "clear.au", "coin.au", "dosun.au", "fumu.au",
                    "gameover.au", "get.au", "happa.au", "item.au", "jump.au", "kiki.au", "mgan.au", "mizu.au",
                    "shot.au", "sjump.au", "tobasu.au");
            mc3 = new McMod("mc3", classes, "game_mt", images, sounds);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        INSTANCES = ImmutableMap.of(McVersion.MC_2_8, mc2, McVersion.MC_3_0, mc3);
    }

    // for resource dir and package replacement
    private String verstr;
    //
    private String defParamName;
    // image file names in resources
    private List<String> images;
    // sound file names in resources
    private List<String> sounds;
    // Class<MasaoConstruction>
    private Class<?> class_mc = null;

    private McMod(String verstr, List<String> classes, String defParamName, List<String> images, List<String> sounds)
            throws IOException, NotFoundException, CannotCompileException {
        this.verstr = verstr;
        this.defParamName = defParamName;
        this.images = images;
        this.sounds = sounds;
        ClassPool cp = ClassPool.getDefault();

        // replace class name map
        var classMap = new ClassMap();
        // inherit AppletMod instead of Applet
        classMap.put("java.applet.Applet", AppletMod.class.getName());
        classMap.put("java.applet.AudioClip", AudioClipMod.class.getName());
        // move to separated package because class names are the same between MC version
        for (var clsName : classes) {
            classMap.put(clsName, PKG_CLS_FMT.formatted(verstr, clsName));
        }
        String rootClassName = PKG_CLS_FMT.formatted(verstr, "MasaoConstruction");

        for (var clsName : classes) {
            var clsNameMod = PKG_CLS_FMT.formatted(verstr, clsName);
            // read class file binary from resources
            byte[] b = Resources.toByteArray(Resources.getResource("%s/class/%s.class".formatted(verstr, clsName)));
            // register to ClassPool
            var cpath = new ByteArrayClassPath(clsName, b);
            cp.insertClassPath(cpath);
            // apply class name replacement
            CtClass ctc = cp.getAndRename(clsName, clsNameMod);
            ctc.replaceClassName(classMap);
            // ctc.debugWriteFile("dbg");
        }
        {
            // raname MasaoConstruction#run() => runHooked()
            CtClass ctc = cp.get(rootClassName);
            CtMethod m = ctc.getMethod("run", "()V");
            m.setName("runHooked");
        }
        for (var clsName : classes) {
            var clsNameMod = PKG_CLS_FMT.formatted(verstr, clsName);
            CtClass ctc = cp.get(clsNameMod);
            // load CtClass as Class
            Class<?> cls = ctc.toClass();
            // keep Class<MasaoConstruction>
            if (clsNameMod.equals(rootClassName)) {
                this.class_mc = cls;
            }
        }
    }

    public static AppletMod constructAppletMod(McVersion ver) {
        try {
            Constructor<?> con = INSTANCES.get(ver).class_mc.getDeclaredConstructor();
            return (AppletMod) con.newInstance();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static List<String> getParamFiles(McVersion ver) {
        String verstr = INSTANCES.get(ver).verstr;

        String src;
        try {
            src = Resources.toString(Resources.getResource("%s/param/list.txt".formatted(verstr)),
                    Charsets.UTF_8);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        return src.lines().toList();
    }

    public static List<McParam> getParam(McVersion ver, String name) {
        McMod inst = INSTANCES.get(ver);
        String verstr = inst.verstr;
        List<McParam> result = new ArrayList<>();

        String src;
        try {
            src = Resources.toString(Resources.getResource("%s/param/%s.txt".formatted(verstr, name)),
                    Charsets.UTF_8);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        Scanner in = new Scanner(src);
        while (in.hasNextLine()) {
            String pname = in.nextLine();
            String value = in.nextLine();
            String comment = in.nextLine();
            result.add(new McParam(pname, value, comment));
        }
        in.close();

        return result;
    }

    public static List<McParam> getDefParams(McVersion ver) {
        return getParam(ver, INSTANCES.get(ver).defParamName);
    }

    public static Map<String, Image> getDefImages(McVersion ver) {
        String verstr = INSTANCES.get(ver).verstr;
        Map<String, Image> result = new HashMap<>();

        for (var name : INSTANCES.get(ver).images) {
            try {
                Image img = ImageIO.read(Resources.getResource("%s/image/%s".formatted(verstr, name)));
                result.put(name, img);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        return result;
    }

    public static Map<String, AudioClipMod> getDefSounds(McVersion ver) {
        String verstr = INSTANCES.get(ver).verstr;
        Map<String, AudioClipMod> result = new HashMap<>();

        for (var name : INSTANCES.get(ver).sounds) {
            try {
                var sound = new AudioClipImpl(
                        Resources.toByteArray(Resources.getResource("%s/sound/%s".formatted(verstr, name))));
                result.put(name, sound);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        return result;
    }

}
