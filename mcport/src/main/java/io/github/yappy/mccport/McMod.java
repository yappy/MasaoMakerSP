/*
 * This source file was generated by the Gradle 'init' task
 */
package io.github.yappy.mccport;

import java.awt.Image;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

import javax.imageio.ImageIO;

import com.google.common.base.Charsets;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.io.Resources;

import io.github.yappy.mcutil.McParam;
import javassist.ByteArrayClassPath;
import javassist.CannotCompileException;
import javassist.ClassMap;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.NotFoundException;

public class McMod {

    public enum McVersion {
        MC_2_8, MC_3_0
    }

    public static int MC_APPLET_W = 512;
    public static int MC_APPLET_H = 320;
    public static int MC_MAP_W = 180;
    public static int MC_MAP_W_PART = 60;
    public static int MC_MAP_H = 30;

    // ....mc2.MasaoConstruction etc.
    private static final String PKG_CLS_FMT = "io.github.yappy.%s.%s";

    // Singleton(s)
    private static final Map<McVersion, McMod> INSTANCES;

    static {
        McMod mc2;
        try {
            List<String> classes = ImmutableList.of(
                    "CharacterObject", "GameGraphics", "GameKey", "GameMouse", "IdouGamen", "KeyboardMenu",
                    "MainProgram", "MapSystem", "MasaoConstruction");
            List<String> images = ImmutableList.of(
                    "chizu.gif", "ending.gif", "gameover.gif", "pattern.gif", "title.gif");
            mc2 = new McMod("mc2", classes, images);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        McMod mc3;
        try {
            List<String> classes = ImmutableList.of(
                    "CharacterObject", "GameGraphics", "GameKey", "GameSound", "GameMouse", "IdouGamen", "KeyboardMenu",
                    "MainProgram", "MapSystem", "MasaoConstruction");
            List<String> images = ImmutableList.of(
                    "chizu.gif", "ending.gif", "gameover.gif", "haikei.gif", "mapchip.gif", "pattern.gif", "title.gif");
            mc3 = new McMod("mc3", classes, images);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        INSTANCES = ImmutableMap.of(McVersion.MC_2_8, mc2, McVersion.MC_3_0, mc3);
    }

    // for resource dir and package replacement
    private String verstr;
    // image file names in resources
    private List<String> images;
    // Class<MasaoConstruction>
    private Class<?> class_mc = null;

    private McMod(String verstr, List<String> classes, List<String> images)
            throws IOException, NotFoundException, CannotCompileException {
        this.verstr = verstr;
        this.images = images;
        ClassPool cp = ClassPool.getDefault();

        // replace class name map
        var classMap = new ClassMap();
        // inherit AppletMod instead of Applet
        classMap.put("java.applet.Applet", "io.github.yappy.mccport.AppletMod");
        // move to separated package because class names are the same between MC version
        for (var clsName : classes) {
            classMap.put(clsName, PKG_CLS_FMT.formatted(verstr, clsName));
        }
        String rootClassName = PKG_CLS_FMT.formatted(verstr, "MasaoConstruction");

        for (var clsName : classes) {
            var clsNameMod = PKG_CLS_FMT.formatted(verstr, clsName);
            // read class file binary from resources
            byte[] b = Resources.toByteArray(Resources.getResource("%s/class/%s.class".formatted(verstr, clsName)));
            // register to ClassPool
            var cpath = new ByteArrayClassPath(clsName, b);
            cp.insertClassPath(cpath);
            // apply class name replacement
            CtClass ctc = cp.getAndRename(clsName, clsNameMod);
            cp.removeClassPath(cpath);
            ctc.replaceClassName(classMap);
            // ctc.debugWriteFile("dbg");
        }
        {
            // raname MasaoConstruction#run() => runHooked()
            CtClass ctc = cp.get(rootClassName);
            CtMethod m = ctc.getMethod("run", "()V");
            m.setName("runHooked");
        }
        for (var clsName : classes) {
            var clsNameMod = PKG_CLS_FMT.formatted(verstr, clsName);
            CtClass ctc = cp.get(clsNameMod);
            // load CtClass as Class
            Class<?> cls = ctc.toClass();
            // keep Class<MasaoConstruction>
            if (clsNameMod.equals(rootClassName)) {
                this.class_mc = cls;
            }
        }
    }

    public static AppletMod constructAppletMod(McVersion ver) {
        try {
            Constructor<?> con = INSTANCES.get(ver).class_mc.getDeclaredConstructor();
            return (AppletMod) con.newInstance();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static List<McParam> getDefParams(McVersion ver) {
        String verstr = INSTANCES.get(ver).verstr;
        List<McParam> result = new ArrayList<>();

        String src;
        try {
            src = Resources.toString(Resources.getResource("%s/%sparam.txt".formatted(verstr, verstr)), Charsets.UTF_8);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        Scanner in = new Scanner(src);
        while (in.hasNextLine()) {
            String name = in.nextLine();
            String value = in.nextLine();
            String comment = in.nextLine();
            result.add(new McParam(name, value, comment));
        }
        in.close();

        return result;
    }

    public static Map<String, Image> getDefImages(McVersion ver) {
        String verstr = INSTANCES.get(ver).verstr;
        Map<String, Image> result = new HashMap<>();

        for (var name : INSTANCES.get(ver).images) {
            try {
                Image img = ImageIO.read(Resources.getResource("%s/image/%s".formatted(verstr, name)));
                result.put(name, img);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        return result;
    }

}
